//按键
uint16 add = 0;//加的标志位
uint16 sub = 0;//减的标志位
int16 key_count = 0;//按键调参的当前参数
uint16 mod;//显示页面的叶数
//按键调参对象
uint16 diangan_mod = 10;//电感采集模式  >=10:归一化    <10：不归一化
int16 rhy = 70;//目标速度
int16 Ang_1 = 90;
int16 X = 4500;

int16 e_b_l_1 = 100;int16 e_b_r_1 = 100;
int16 e_b_l_2 = 10;	int16 e_b_r_2 = 60;
int16 e_b_l_3 = 50;	int16 e_b_r_3 = 20;
int16 X_l = 8000;	int16 X_r = 8000;
int16 Ang_b_l = 140;		int16 Ang_b_r = 140;
int16 e_huan_l_in = 5;	int16 e_huan_r_in = 25;
int16 e_huan_l_out = 12;	int16 e_huan_r_out = 25;

//显示以及按键调参
void show(void)
{
	while(mod == 1)//显示数据模式
	{
		//显示信息面板
		ips114_clear(WHITE);//清屏
		ips114_showstr(1, 1, "error");
		ips114_showstr(0, 2, "spe_l=");	ips114_showstr(12*10, 2, "spe_r =");
		ips114_showstr(0, 3, "pwm_l =");ips114_showstr(12*10, 3, "pwm_r =");	
		ips114_showstr(0,4,"spe-targ="); 	
		ips114_showstr(0,5,"Angle="); 
		ips114_showstr(0,6,"bizhang:"); ips114_showstr(13*10,6,"huan:"); 
		ips114_showstr(0, 7, "step-bz=");ips114_showstr(13*10, 7, "dist");
		
		while(mod ==1)
		{
			//按键切换模式
			switch(KEY_Read(0))//（不支持连按）
			{
				case 1:
				{
					mod ++;
					break;//跳出循环
				}
				break;
				
				default:
				break;
					
			}
			//不断刷新显示
			ips114_showint32(0,0,ad[0],4);ips114_showint32(4*10,0,ad[1],4);ips114_showint32(9*10,0,ad[2],4);ips114_showint32(14*10,0,ad[3],4);ips114_showint32(18*10,0,ad[4],4);	
			ips114_showint32(6*10,1,error,6);		
			ips114_showint32(6*10, 2, speed_l,3);		ips114_showint32(18*10,2,speed_r,3);	
			ips114_showint32(6*10, 3, pwm_l,4);		ips114_showint32(18*10,3,pwm_r,4);
			ips114_showint16(12*10, 4, speed_targe);	
			ips114_showint16(12*10, 5, (int16)(FJ_Angle));
			if(type_bz == 0)		ips114_showstr(8*10, 6, "left");//避障类型
			else if(type_bz == 1)ips114_showstr(8*10, 6, "righ");
			else if(type_bz == 2)ips114_showstr(8*10, 6, "NO");
			if(type == 0)		ips114_showstr(185, 6, "righ");//圆环类型
			else if(type == 1)ips114_showstr(185, 6, "left");
			else if(type == 2)ips114_showstr(185, 6, "NO");			
			ips114_showint16(6*10, 7,flag_bizhang);
											if(dl1a_finsh_flag)
											{
												ips114_showint16(18*10,7,dl1a_distance_mm);
												dl1a_finsh_flag = 0;
											}
		}
			
	}
	while(mod == 2)//调节速度和模式
	{
		key_count = 1;
		ips114_clear(WHITE);//清屏
		//显示信息面板
		ips114_showstr(1*10,0,"SPEED=");	
		ips114_showstr(1*10,1,"Kp_T=");
		ips114_showstr(1*10,2,"Kd-T=");
		ips114_showstr(1*10,3,"bz-mod:");
		ips114_showstr(1*10,4,"yuanhuan-mod:");	
		while(mod == 2)
		{
			switch(KEY_Read(1))//（支持连按）
			{
				case 0:
					//delay_ms(5);
					break;
				case 1:
				{
					mod++;
					//delay_ms(5);
					break;//跳出循环
				}
				break;
				case 2:
				{	
					key_count ++;
					//delay_ms(5);
				}
					break;
				case 3:
				{
					//delay_ms(5);
					add = 1;
				}
					break;
				case 4:
				{
					//delay_ms(5);
					sub = 1;
				}
					break;
			}
			if(key_count > 5)	key_count = 1;//翻滚菜单
			if(type_bz > 2)	type_bz = 2;
			else if(type_bz < 0)	type_bz = 0;
			if(type > 2)	type = 2;
			else if(type < 0)	type = 0;			
			for(i = 1;i<6;i++)//显示选择哪个进行更改
			{
				if(i == (int)key_count)	ips114_showstr(0,i-1,"*");	
				else	ips114_showstr(0,i-1," ");
			}
			if(add == 1 || sub == 1)//按键调参
			{
				//当前修改哪一个对象？
				if(key_count ==1)
					rhy = rhy + 5*add - 5*sub;
				else if(key_count ==2)
					Kp_T = Kp_T + 2*add -2*sub;
				else if(key_count ==3)
					Kd_T = Kd_T + 100*add -100*sub;
				else if(key_count ==4)
					type_bz = type_bz + 1*add - 1*sub;
				else if(key_count ==5)
					type = type + 1*add - 1*sub;
				//归零（保证按一下只修改一次）
				add = 0;sub = 0;
			}
			ips114_showint16(8*10,0,rhy);
			ips114_showint16(8*10,1,Kp_T);
			ips114_showint16(8*10,2,Kd_T);
			if(type_bz == 0)		ips114_showstr(13*10, 3, "left");//避障类型
			else if(type_bz == 1)ips114_showstr(13*10, 3, "righ");
			else if(type_bz == 2)ips114_showstr(13*10, 3, "NO  ");
			if(type == 0)			ips114_showstr(13*10, 4, "righ");//圆环类型
			else if(type == 1)	ips114_showstr(13*10, 4, "left");
			else if(type == 2)	ips114_showstr(13*10, 4, "NO  ");	
			

			
		}
	}
	while(mod == 3)//调节圆环参数
	{
		key_count = 1;
		ips114_clear(WHITE);//清屏
		//显示信息面板
		ips114_showstr(1*10,0,"direction:");	
		ips114_showstr(1*10,1,"left-error-in=");
		ips114_showstr(1*10,2,"left-error-out=");
		ips114_showstr(1*10,3,"righ-error-in=");
		ips114_showstr(1*10,4,"righ-error-out=");	
		while(mod == 3)
		{
			switch(KEY_Read(1))//（支持连按）
			{
				case 0:
					//delay_ms(5);
					break;
				case 1:
				{
					mod++;
					//delay_ms(5);
					break;//跳出循环
				}
				break;
				case 2:
				{	
					key_count ++;
					//delay_ms(5);
				}
					break;
				case 3:
				{
					//delay_ms(5);
					add = 1;
				}
					break;
				case 4:
				{
					//delay_ms(5);
					sub = 1;
				}
					break;
			}
			if(key_count > 4)	key_count = 1;//翻滚菜单
			for(i = 1;i<5;i++)//显示选择哪个进行更改
			{
				if(i == (int)key_count)	ips114_showstr(0,i,"*");	
				else	ips114_showstr(0,i," ");
			}
			if(add == 1 || sub == 1)//按键调参
			{
				//当前修改哪一个对象？
				if(key_count ==1)
					e_huan_l_in = e_huan_l_in + add -sub;
				else if(key_count ==2)
					e_huan_l_out = e_huan_l_out + 1*add -1*sub;
				else if(key_count ==3)
					e_huan_r_in = e_huan_r_in + 1*add - 1*sub;
				else if(key_count ==4)
					e_huan_r_out = e_huan_r_out + 1*add - 1*sub;
				//归零（保证按一下只修改一次）
				add = 0;sub = 0;
			}
			if(type == 0)			ips114_showstr(9*10, 0, "righ");//避障类型
			else if(type == 1)	ips114_showstr(9*10, 0, "left");
			else if(type == 2)	ips114_showstr(9*10, 0, "NO  ");
			ips114_showint16(12*10,1,e_huan_l_in);    
			ips114_showint16(12*10,2,e_huan_l_out); 
			ips114_showint16(12*10,3,e_huan_r_in); 
			ips114_showint16(12*10,4,e_huan_r_out); 
		}
			
	
		
	}

	while(mod == 4)//调节避障参数
	{
		key_count = 1;
		ips114_clear(WHITE);//清屏
		//显示信息面板
		ips114_showstr(1*10,0,"direction:");	
		ips114_showstr(1*10,1,"error-1");
		ips114_showstr(1*10,2,"X");
		ips114_showstr(1*10,3,"error-2");
		ips114_showstr(1*10,4,"error-3");	
		ips114_showstr(1*10,4,"huizheng");
		while(mod == 4)
		{
			switch(KEY_Read(1))//（支持连按）
			{
				case 0:
					//delay_ms(5);
					break;
				case 1:
				{
					mod = 1;
					//delay_ms(5);
					break;//跳出循环
				}
				break;
				case 2:
				{	
					key_count ++;
					//delay_ms(5);
				}
					break;
				case 3:
				{
					//delay_ms(5);
					add = 1;
				}
					break;
				case 4:
				{
					//delay_ms(5);
					sub = 1;
				}
					break;
			}
			if(key_count > 5)	key_count = 1;//翻滚菜单
			for(i = 1;i<6;i++)//显示选择哪个进行更改
			{
				if(i == (int)key_count)	ips114_showstr(0,i,"*");	
				else	ips114_showstr(0,i," ");
			}
			if(add == 1 || sub == 1)//按键调参
			{
				//当前修改哪一个对象？
				if(key_count == 1 && type_bz == 0)
					e_b_l_1 = e_b_l_1 + 1*add - 1*sub;
				if(key_count == 1 && type_bz == 1)
					e_b_r_1 = e_b_r_1 + 1*add - 1*sub;
				if(key_count ==2 && type_bz == 0)
					X_l = X_l + 100*add - 100*sub;
				if(key_count == 2 && type_bz == 1)
					X_r = X_r + 100*add - 100*sub;
				if(key_count == 3 && type_bz == 0)
					e_b_l_2 = e_b_l_2 + 1*add - 1*sub;
				if(key_count == 3 && type_bz == 1)
					e_b_r_2 = e_b_r_2 + 1*add - 1*sub;
				if(key_count == 4 && type_bz == 0)
					e_b_l_3 = e_b_l_3 + 1*add - 1*sub;
				if(key_count == 4 && type_bz == 1)
					e_b_r_3 = e_b_r_3 + 1*add - 1*sub;
				if(key_count == 5 && type_bz == 0)
					Ang_b_l = Ang_b_l + 2*add - 2*sub;	
				if(key_count == 5 && type_bz == 1)
					Ang_b_r = Ang_b_r + 2*add - 2*sub;				
				//归零（保证按一下只修改一次）
				add = 0;sub = 0;
			}
			if(type_bz == 0)		ips114_showstr(15*10, 0, "left");//避障类型
			else if(type_bz == 1)	ips114_showstr(15*10, 0, "righ");
			else if(type_bz == 2)	ips114_showstr(15*10, 0, "NO  ");
			ips114_showint16(12*10,1,e_b_l_1);		 ips114_showint16(18*10,1,e_b_r_1);   
			ips114_showint16(12*10,2,X_l); 		ips114_showint16(18*10,2,X_r);
			ips114_showint16(12*10,3,e_b_l_2); 	ips114_showint16(18*10,3,e_b_r_2);
			ips114_showint16(12*10,4,e_b_l_3); 	ips114_showint16(18*10,4,e_b_r_3);
			ips114_showint16(12*10,5,Ang_b_l); 	ips114_showint16(18*10,5,Ang_b_r);
		}
			
	
		
	}



}