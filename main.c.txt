//main.c
/*************************************************************
*【时间】7.16
*【功能】1.4m 完赛
*【更新时间】7.16
*
****************************************************************/
#include "headfile.h"
//引脚宏定义
#define SPEEDL_PLUSE   CTIM0_P34
#define SPEEDR_PLUSE   CTIM3_P04
#define SPEEDL_DIR     P35
#define SPEEDR_DIR     P53
#define BEEP P32//蜂鸣器
#define KEY_1 P50//换mod
#define KEY_2 P16//换key
#define KEY_3 P17//add
#define KEY_4 P51//sub
//load(1)
#define FOSC	11059200UL
#define BAUD	(65535 - (FOSC/115200+2)/4)

int index;
int16 i;//for专用

//计时间 计数变量
uint32 temp_count = 0;//已使用， 作为入环允许标志的计时复位

//标志位（苯环,避障,丢线）
int16 flag_chuhuan = 0;//出环第0阶段标志 允许入环
int16 flag_bizhang = 0;//还未执行避障
int16 flag_diuxian = 0;//0:正常熏鸡  1:丢线
uint16 flag_zhijiao = 0;//0:正常熏鸡  1:左直角  2：右直角
int16 typ = 0;//0:右圆环   1：左圆环  3:不尽欢

//速度
int32 pwm_l=0, pwm_r=0;
int32 suduhuan=0;
int32 xunji = 0;
extern int16 speed_l,speed_r;
int16 speed_targe = 90;//目标速度

//里程
volatile int32 Sum_left = 0;
volatile int32 Sum_right = 0;

//角度
float FJ_Angle = 0; 

//采集值
float error_a;
float error_b;
float error;//电感误差值
float error_s;//实际差速
int16 ad[5]={0,0,0,0,0};//电感采集初始值
int32 adcgetdata_max[5]={3585,3580,3500,3500,3590};//电感最大值
int32 adcgetdata_min[5]={0,0,0,0,0};

//按键
uint16 add = 0;//加的标志位
uint16 sub = 0;//减的标志位
int16 key_count = 0;//按键调参的当前参数
uint16 mod;//显示页面的叶数
//按键调参对象
uint16 diangan_mod = 10;//电感采集模式  >=10:归一化    <10：不归一化
int16 rhy = 180;//目标速度
int16 Ang_1 = 90;
int16 X = 4500;
int16 e_a = 15;

//函数声明
void sys_init(void);
void output(void);
void show(void);
int16 KEY_Read(uint8 mode);
uint32 seekfree_assistant_transfer_callback(const uint8 *buff, uint32 length);//示波器
void Ang_reset(void);
void upload_init(void);

//总限幅，以及输出PWM 
void output() 
{ 
	if(pwm_r>8000)      //总限幅 
        pwm_r=8000; 
     else if(pwm_r<-8000) 
        pwm_r=-8000; 
    if(pwm_l>=8000) 
        pwm_l=8000; 
    else if(pwm_l<-8000) 
        pwm_l=-8000; 
	if(pwm_l<=0)       
	{ 
          pwm_duty(PWMA_CH3P_P24,-pwm_l); 
		pwm_duty(PWMA_CH4P_P26,0); 
	} 
    else if(pwm_l>0) 
	{ 
		pwm_duty(PWMA_CH3P_P24,0); 
		pwm_duty(PWMA_CH4P_P26,pwm_l); 
	} 
	if(pwm_r<=0)       
	{ 
		pwm_duty(PWMA_CH1P_P10,-pwm_r); 
		pwm_duty(PWMA_CH2N_P13,0); 
	} 
	else if(pwm_r>0) 
	{ 
		 pwm_duty(PWMA_CH1P_P10,0); 
		 pwm_duty(PWMA_CH2N_P13,pwm_r); 
	} 
} 
 
 
 
//小车变量，函数初始化 
void init() 
{ 
	clock_init(SYSTEM_CLOCK_56M);	// 初始化系统频率,勿删除此句代码。 
	board_init();			 		// 初始化寄存器,勿删除此句代码。 
	 
	ctimer_count_init(SPEEDL_PLUSE);	//初始化定时器0作为外部计数 
	ctimer_count_init(SPEEDR_PLUSE);	//初始化定时器3作为外部计数 
	ips114_init();// 
	//六轴陀螺仪初始化 
	while(imu660ra_init())				//六轴陀螺仪初始化 
	{ 
		delay_ms(500); 
		ips114_showstr(0, 0, "Tuo Init Fail！"); 
	}	 
	 
	//測距初始化 
	while(dl1a_init()) 
	{ 
		delay_ms(500); 
		ips114_showstr(0, 1, "DllA Init Fail！"); 
	} 
	pit_timer_ms(TIM_4, 20); 
	pit_timer_ms(TIM_1, 1);//用于苯环定时 
	 
	//电感采集初始化 
	adc_init(ADC_P15,ADC_SYSclk_DIV_2); 
	adc_init(ADC_P14,ADC_SYSclk_DIV_2); 
	adc_init(ADC_P01,ADC_SYSclk_DIV_2); 
	adc_init(ADC_P11,ADC_SYSclk_DIV_2); 
	adc_init(ADC_P06,ADC_SYSclk_DIV_2); 
	 
	pwm_init(PWMA_CH1P_P10,17000,0); 
	pwm_init(PWMA_CH2N_P13,17000,0); 
	pwm_init(PWMA_CH3P_P24,17000,0); 
	pwm_init(PWMA_CH4P_P26,17000,0); 
 
	//蜂鸣器 
	gpio_mode(P3_2,GPO_PP);	// 将P3.2设置为推挽输出 
	BEEP = 0; 
	//按键控制 
	mod = 1; 
	//示波器 
	if(0) 
	{ 
		// 设置函数指针(示波器) 
//		seekfree_assistant_transfer = seekfree_assistant_transfer_callback; 
//		// 需要传输四个通道数据(示波器绑定数值初始化) 
//		// 设置数据 
//		seekfree_assistant_oscilloscope_data.dat[0] = pwm_l; 
//		seekfree_assistant_oscilloscope_data.dat[1] = speed_r; 
//		seekfree_assistant_oscilloscope_data.dat[2] = speed_l; 
//		seekfree_assistant_oscilloscope_data.dat[3] = speed_targe; 
//		seekfree_assistant_oscilloscope_data.channel_num = 4; 
	} 
	 
} 
 
//显示以及按键调参
void show(void)
{
	while(mod == 1)//显示数据模式
	{
		//显示信息面板
		ips114_clear(WHITE);//清屏
		ips114_showstr(14*10, 1, "mod");
		ips114_showstr(0, 1, "error");ips114_showstr(0,1," ");
		ips114_showstr(0,2," ");ips114_showstr(0, 4, " ");
		ips114_showstr(0,3," ");ips114_showstr(0,5," ");
	    
		ips114_showstr(14*10, 2, "spe_l=");	ips114_showstr(14*10, 3, "spe_r =");
		ips114_showstr(14*10, 4, "pwm_l =");ips114_showstr(14*10, 5, "pwm_r =");	
		ips114_showstr(0,4,"speed="); ips114_showstr(14*10, 6, "dist");	
		ips114_showstr(0,5,"step="); 
		ips114_showstr(0,6,"Angle="); 
		ips114_showstr(0, 7, "left=");
		
		while(mod ==1)
		{
			//按键切换模式
			switch(KEY_Read(0))//（不支持连按）
			{
				case 1:
				{
					mod ++;
					break;//跳出循环
				}
				break;
				
				default:
				break;
					
			}
			//不断刷新显示
			ips114_showint32(0,0,ad[0],4);
			ips114_showint32(4*10,0,ad[1],4);		ips114_showint32(14*10,0,ad[3],4);
			ips114_showint32(9*10,0,ad[2],4);		ips114_showint32(18*10,0,ad[4],4);
			ips114_showuint16(18*10,1,mod);		ips114_showint32(8*10,1,error,6);
			ips114_showint16(18*10, 2, speed_l);
			ips114_showint16(18*10, 3, speed_r);
			ips114_showint16(8*10, 4, speed_targe);	ips114_showint32(18*10, 4, pwm_l,5);
			ips114_showint16(8*10, 5, flag_bizhang);ips114_showint32(18*10, 5, pwm_r,5);	
			ips114_showint16(8*10, 6, FJ_Angle);
			ips114_showint32(8*10, 7,Sum_left,5);

											if(dl1a_finsh_flag)
											{
												ips114_showint16(18*10,6,dl1a_distance_mm);
												dl1a_finsh_flag = 0;
											}
			//示波器数据发送
			// 通过串口发送虚拟示波器数据
//			seekfree_assistant_oscilloscope_send(&seekfree_assistant_oscilloscope_data);
			delay_ms(1);
		}
			
	}
	while(mod == 2)//调节数据模式
	{
		ips114_clear(WHITE);//清屏
		//显示信息面板
		ips114_showstr(0,0,"mod");ips114_showstr(14*10,0,"SPEED=");	
		ips114_showstr(0,1,"key");ips114_showstr(14*10,1,"Kp_T=");
							ips114_showstr(14*10,2,"Kd-T=");
							ips114_showstr(14*10,3,"X=");
							ips114_showstr(14*10,4,"Ki_s=");	
							ips114_showstr(14*10,5,"Kd_T=");
							ips114_showstr(14*10,6,"dg_mod");
		
		while(mod == 2)
		{
			switch(KEY_Read(1))//（支持连按）
			{
				case 0:
					//delay_ms(5);
					break;
				case 1:
				{
					mod --;
					//delay_ms(5);
					break;//跳出循环
				}
				break;
				case 2:
				{	
					key_count ++;
					//delay_ms(5);
				}
					break;
				case 3:
				{
					//delay_ms(5);
					add = 1;
				}
					break;
				case 4:
				{
					//delay_ms(5);
					sub = 1;
				}
					break;
			}
			if(key_count >= 8)	key_count = 1;//翻滚菜单
			for(i = 1;i<8;i++)//显示选择哪个进行更改
			{
				if(i == (int)key_count)	ips114_showstr(13*10,i-1,"*");	
				else	ips114_showstr(13*10,i-1," ");
			}
			if(add == 1 || sub == 1)//按键调参
			{
				//当前修改哪一个对象？
				if(key_count ==1)
					rhy = rhy + 5*add - 5*sub;
				else if(key_count ==2)
					Kp_T = Kp_T + add -sub;
				else if(key_count ==3)
					Kd_T = Kd_T + add -sub;
				else if(key_count ==4)
					X = X+ 100*add - 100*sub;
				else if(key_count ==5)
					Ki_s = Ki_s + 0.01*add - 0.01*sub;
				else if(key_count == 6)
					Kd_T = Kd_T+ 100*add - 100*sub;
				else if(key_count == 7)
					diangan_mod = diangan_mod + 1*add - 1*sub;
				//归零（保证按一下只修改一次）
				add = 0;sub = 0;
			}
			ips114_showint16(4*10,0,mod);      ips114_showint16(18*10,0,rhy);
			ips114_showint16(4*10,1,key_count);ips114_showint16(18*10,1,Kp_T);
			ips114_showint16(4*10,2,speed_targe);ips114_showint16(18*10,2,Kd_T);
										ips114_showint16(18*10,3,X);			
										ips114_showint16(18*10,4,(int16)(100*Ki_s));			
										ips114_showint16(18*10,5,Kd_T);
										ips114_showint16(18*10,6,diangan_mod);
			
			//示波器数据发送
//			seekfree_assistant_oscilloscope_send(&seekfree_assistant_oscilloscope_data);
//			delay_ms(1);
		}
			
	
		
	}
}
 
 
//采集电感值和速度 
void caiji_data() 
{ 
	//采集电感 
	ad[0]=adc_once(ADC_P14, ADC_12BIT); 
	ad[1]=adc_once(ADC_P15, ADC_12BIT); 
	ad[2]=adc_once(ADC_P11, ADC_12BIT); 
	ad[3]=adc_once(ADC_P06, ADC_12BIT); 
	ad[4]=adc_once(ADC_P01, ADC_12BIT); 
	if(0)//直角作为特殊元素处理（@4）
	{
		if( (ad[1]%100) > (ad[3]%100) * 4 )
		{	flag_zhijiao = 1;//左直角
			Ang_reset();
		}
		else if( (ad[1]%100) * 4 < (ad[3]%100) )
		{	flag_zhijiao = 2;//右直角
			Ang_reset();
		}
		else
			flag_zhijiao = 0;//正常熏鸡
	}
	//判断丢线(避障的第一步即打脚时也默认丢线不给速度)（避障第二步不能丢线） 
	if((ad[0]+ad[1]+ad[3]+ad[4] < 100 || flag_bizhang == 1 || flag_zhijiao == 1 ||flag_zhijiao == 2)
									&&(flag_bizhang != 2 && flag_bizhang !=3))	
		flag_diuxian = 1;//丢线 
	else 
		flag_diuxian = 0;//没丢 
	if(diangan_mod >= 10)//大于10为归一化模式 否则为原始值 
	{ 
		for(i=0;i<2;i++)//(1)（2） 
	    { 
		   ad[i]=(ad[i]-adcgetdata_min[i])*100/(adcgetdata_max[i]-adcgetdata_min[i]);  
		   if(ad[i]<=0) 
		   { 
			  ad[i]=0; 
		   } 
		   else if(ad[i]>=100) 
		   { 
			  ad[i]=100; 
		   } 
		   
	    } 
	    for(i=3;i<5;i++)//(1)（2） 
	    { 
		   ad[i]=(ad[i]-adcgetdata_min[i])*100/(adcgetdata_max[i]-adcgetdata_min[i]);  
		   if(ad[i]<=0) 
		   { 
			  ad[i]=0; 
		   } 
		   else if(ad[i]>=100) 
		   { 
			  ad[i]=100; 
		   } 
		   
	    } 
    } 
 
//    if(flag_diuxian == 0)//没有丢线的正常情况 
//    { 
		error_a = sqrt(ad[0]*ad[0] +ad[1]*ad[1]); 
		error_b = sqrt(ad[3]*ad[3] +ad[4]*ad[4]); 
		error = (error_a - error_b) * 100 /(error_a + error_b + 1);//差比和 
	    if(error > 100)	error = 100; 
	    if(error < -100)	error = -100; 
//    } 
//    else//丢线了 也不左右乱晃 
//    	    error = 0; 
	 
    //采集速度 
	speed_r = ctimer_count_read(SPEEDR_PLUSE); 
	speed_l = ctimer_count_read(SPEEDL_PLUSE); 
	//编码器采集值清零 
	ctimer_count_clean(SPEEDL_PLUSE); 
	ctimer_count_clean(SPEEDR_PLUSE); 
	if(0 == SPEEDL_DIR)     
	{ 
		speed_l = -speed_l; 
	} 
	 
	if(1 == SPEEDR_DIR)     
	{ 
		speed_r = -speed_r; 
	} 
	//编码器积分 
	Sum_left += speed_l; 
	Sum_right += speed_r; 
	 
    //采集角度 
	imu660ra_get_gyro();    	//获取陀螺仪数据 
	FJ_Angle = Get_Gyroscope_Angle(imu660ra_gyro_z);//代入角速度，得到一个角度值 
 
	//采集距离 
	dl1a_get_distance(); 
} 
 
 
//判断路况 
void panduan() 
{ 
/////////////////////////////////////////////圆环////////////////////////////////////////////	 
	if(0)//(1.陀螺仪+编码器) 
	{ 
		if(typ==0)//(右圆环) 
		{ 
			//陀螺仪苯环测试 
			if(ad[2]>=3500  && flag_chuhuan == 0)//第一阶段 清零；进入下一阶段(ad[2]>=3500 && ad[0]>=0 && ad[1]>=0 && chuhuan>0  && (flag_bizhang ==0 || flag_bizhang ==4)) 
			{ 
				flag_chuhuan = 1; 
				Ang_reset(); 
				Sum_left = 0; 
			}	 
			if(flag_chuhuan == 1)//第2阶段 覆盖error；右转入环 
			{ 
				if(Sum_left <= 5500) 
					error = -30; 
				else 
				{ 
					flag_chuhuan = 2; 
				} 
			} 
			 
			if(flag_chuhuan == 2 && abs(FJ_Angle) >= 580)//第3阶段 覆盖error；直行出环 
			{ 
				Sum_left = 0; 
				flag_chuhuan = 3; 
			} 
			if(flag_chuhuan == 3)//第3阶段 覆盖error；直行出环 
				if(Sum_left <= 6500) 
					error = 20; 
				else 
				{	flag_chuhuan = 4; 
					typ = 1;//右接左 
	//				typ = 0;//右接右 
				} 
		} 
	 
	 
		if(typ== 1)//(左圆环) 
		{ 
			//陀螺仪苯环测试 
			if(ad[2]>=3500  && flag_chuhuan == 0)//第一阶段 清零；进入下一阶段(ad[2]>=3500 && ad[0]>=0 && ad[1]>=0 && chuhuan>0  && (flag_bizhang ==0 || flag_bizhang ==4)) 
			{ 
				flag_chuhuan = 1; 
				Ang_reset(); 
				Sum_right = 0; 
			}	 
			if(flag_chuhuan == 1)//第2阶段 覆盖error；右转入环 
			{ 
				if(Sum_right <= 7000) 
					error = e_a; 
				else 
				{ 
					flag_chuhuan = 2; 
				} 
			} 
			 
			if(flag_chuhuan == 2 && abs(FJ_Angle) >= 580)//第3阶段 覆盖error；直行出环 
			{ 
				Sum_right = 0; 
				flag_chuhuan = 3; 
			} 
			if(flag_chuhuan == 3)//第3阶段 覆盖error；直行出环 
				if(Sum_right <= X) 
					error = -20; 
				else 
				{ 
					flag_chuhuan = 4; 
	//				typ = 1;//左接左 
					typ = 0;//左接右 
				} 
		} 
			 
 
	} 
	 
	if(0) 
	{ 
	//	if(0)//(2.里程差)	//可以（2）&（3）结合使用 
//	{ 
//		if(mou)//符合入环条件，入环并且开始采集 
//		{ 
//			sumleft = 0; 
//			sumright = 0; 
//			flag_chuhuan = 1;//进入第二阶段 
//			 
//		} 
//		if()//第二阶段 
//		{ 
//			error = 10;//打较入环 
//			 
//		} 
//		else if()//第二阶段结束条件 
//		{ 
//			flag_chuhuan = 2;//进入第3阶段 
//		} 
//		if()//第3阶段 检测编码器差值 
//		{ 
//			error = 0;//打较出环 
//			 
//		} 
//		else if()//第3阶段结束条件 
//		{ 
//			flag_chuhuan = 3;//结束flag_chuhuan = 0 
//		} 
//	} 
//	if(0)//(3.直接打教出环) 
//	{ 
//		if() 
//		{ 
//			//固定速度标志 
//			 
//			error = 30;//固定error 
//		} 
//		else if()//编码器条件 
//		{ 
//			 
//		} 
//	} 
	} 
 
 
/////////////////////////////////////////////避障////////////////////////////////////// 
	if(0) 
	{ 
	//避障，覆盖采集的error值,并且只有flag_bizhang = 0或3，其他正常熏鸡才开启 
		if(dl1a_distance_mm>700&& dl1a_distance_mm < 800 && flag_bizhang ==0 && abs(error) <= 15) 
		{ 
			flag_bizhang = 1;//已避障 
			Ang_reset();//进入避障环节，角度清零 
		}	 
		if(flag_bizhang == 1) 
		{ 
			if(FJ_Angle <= 40) 
				error = 100;// 
			else if(FJ_Angle > 40) 
			{ 
				flag_bizhang = 2; 
				Sum_left = 0; 
			}		 
		} 
		if(flag_bizhang == 2) 
		{ 
			if(Sum_left <= 8000) 
				error = -15;// 
			else if(Sum_left > 8000) 
			{ 
				flag_bizhang = 3; 
				Ang_reset(); 
			}		 
		} 
		if(flag_bizhang == 3) 
		{ 
			if(FJ_Angle >= -67) 
				error = -30; 
			else if(FJ_Angle <-67) 
			{ 
				flag_bizhang = 4; 
				Ang_reset(); 
			} 
		} 
	} 
	 
/////////////////////////////////////////////直角////////////////////////////////////// 
	if(0)
	{
		if(flag_zhijiao == 1)
		{
			if( FJ_Angle <=100 )
				error = 90;
			else if(FJ_Angle >100)
				flag_zhijiao = 0;//正常熏鸡
		}
		else if(flag_zhijiao == 1)
		{
			if( FJ_Angle >=-100 )
				error = -90;
			else if(FJ_Angle <-100)
				flag_zhijiao = 0;//正常熏鸡
		}
	}
	
//	转向环 
	xunji = pidxunxian_T(error,imu660ra_gyro_z);
	pwm_l = 0 - xunji;// pwm? ? 
	pwm_r = 0 + xunji;//  pwm? ?	 
 
//  速度环 
	if(flag_diuxian == 0)//没有丢线 
		speed_targe = rhy+ rhy*(-0.000333*(ad[1] - ad[3])*(ad[1] - ad[3]) + 0.000333 *abs((ad[1] - ad[3])));//speed_targe = rhy+ rhy*(-0.000178*(ad[1] - ad[3])*(ad[1] - ad[3]) - 0.006 *abs((ad[1] - ad[3]))) 
	else if(flag_diuxian == 1)//丢线不乱跑 
		speed_targe = 0; 
	error_s = (2*speed_targe - speed_l -speed_r)/2; 
	suduhuan = pidpwm_l(error_s); 
	pwm_l += suduhuan; 
	pwm_r += suduhuan; 
 
	 
	//示波器调速度环 
	if(0) 
	{ 
		speed_targe = rhy; 
		error_s = (2*speed_targe - speed_l -speed_r)/2; 
		//error_s = speed_targe - speed_l; 
		suduhuan = pidpwm_l(error_s); 
		pwm_l += suduhuan; 
		pwm_r += suduhuan; 
		//更新示波器显示值 
//			seekfree_assistant_oscilloscope_data.dat[0] = pwm_l; 
//			seekfree_assistant_oscilloscope_data.dat[1] = speed_r; 
//			seekfree_assistant_oscilloscope_data.dat[2] = speed_l; 
//			seekfree_assistant_oscilloscope_data.dat[3] = speed_targe; 
	} 
		 
} 
 
 
 
 
 
void main() 
{  
	 
	//编码器启动用的 
//	sys_init(); //弄了自动下载，一个是好像和这个冲突，另一个是这个变的会导致无法reset
	EA = 1;
	
	//load(2)
	//upload初始化
//	upload_init();加了容易电感跳变
	init();//初始化 
	while(1) 
	{ 
		show(); 
		if(0)//测试电机正反转 
		{ 
			pwm_l = 2500; 
			pwm_r = 0; 
			output(); 
			delay_ms(2000); 
			 
			pwm_l =  0; 
			pwm_r = 2500; 
			output(); 
			delay_ms(2000); 
			 
			pwm_l = -2500; 
			pwm_r = 0; 
			output(); 
			delay_ms(2000); 
			 
			pwm_l = 0; 
			pwm_r = -2500; 
			output(); 
			delay_ms(2000); 
		}		 
	} 
} 
//基本寻迹中断函数 
void pit_callback() 
{ 
	caiji_data();//采集电感值和速度 
	panduan();//用采集的电感值和速度，判断路面情况，并进行调节， 
	output();//判断得到的pwm输出给两个轮子 
} 
 
//计时中断 
void pit_callback_1() 
{ 
	if(flag_chuhuan == 4) 
		if(temp_count++ >= 1500)//3s 
		{ 
			temp_count = 0;//复位 
			flag_chuhuan = 0;//复位 
		} 
} 
//编码器初始化之一
void sys_init()
{
    WTST = 0;  //设置程序指令延时参数，赋值为0可将CPU执行指令的速度设置为最快
    EAXFR = 1; //扩展寄存器(XFR)访问使能
    CKCON = 0; //提高访问XRAM速度

    P0M1 = 0x30;   P0M0 = 0x30;   //设置P0.4、P0.5为漏极开路(实验箱加了上拉电阻到3.3V)
    P1M1 = 0x32;   P1M0 = 0x32;   //设置P1.1、P1.4、P1.5为漏极开路(实验箱加了上拉电阻到3.3V), P1.1在PWM当DAC电路通过电阻串联到P2.3
    P2M1 = 0x3c;   P2M0 = 0x3c;   //设置P2.2~P2.5为漏极开路(实验箱加了上拉电阻到3.3V)，设置开漏模式需要断开PWM当DAC电路中的R2电阻
    P3M1 = 0x50;   P3M0 = 0x50;   //设置P3.4、P3.6为漏极开路(实验箱加了上拉电阻到3.3V)
    P4M1 = 0x3c;   P4M0 = 0x3c;   //设置P4.2~P4.5为漏极开路(实验箱加了上拉电阻到3.3V)
    P5M1 = 0x0c;   P5M0 = 0x0c;   //设置P5.2、P5.3为漏极开路(实验箱加了上拉电阻到3.3V)
    P6M1 = 0xff;   P6M0 = 0xff;   //设置为漏极开路(实验箱加了上拉电阻到3.3V)
    P7M1 = 0x00;   P7M0 = 0x00;   //设置为准双向口
}
 
//自动下载初始化设置
void upload_init()
{
	P0M0 = 0x00;P0M1 = 0x00;
	P1M0 = 0x00;P1M1 = 0x00;
	P2M0 = 0x00;P2M1 = 0x00;
	P3M0 = 0x00;P3M1 = 0x00;
	
	SCON = 0x50;
	AUXR = 0x40;
	TMOD = 0x00;
	TH1 = BAUD>>8;
	TL1 = BAUD;
	TR1 = 1;
	ES = 1;
	EA = 1;
	
	index = 0;
}
//按键 
int16 KEY_Read(uint8 mode) 
{ 
    static uint8 key_up=1;     //按键松开标志 
    //当设置成可连按  
    if(mode==1) 
    { 
      key_up=1;      //支持连按 
    } 
    //检测按下的是哪个按键，只要未按下，或者按下了但是可以连按，就继续检测 
    if(key_up && (KEY_1==0 || KEY_2==0 || KEY_3==0 || KEY_4==0)) 
    { 
      delay_ms(20);                      //按键消抖 
      key_up=0; 
      if(KEY_1==0)       
      { 
          return 1;//换mod换keyaddsub 
      } 
      else if(KEY_2==0)       
      { 
          return 2;//换key 
      } 
       
      else if(KEY_3==0)       
      { 
          return 3;//add 
      } 
	 else if(KEY_4==0)       
      { 
          return 4;//sub 
      } 
	  
    } 
    //若都没有按下,"按键松开标志"重置为1，可继续按键 
    if(KEY_1 ==1 && KEY_2==1 && KEY_3==1 && KEY_4==1) 
    { 
     key_up=1;    
    } 
    return 0;   //无按键按下 
} 
 
//示波器 
uint32 seekfree_assistant_transfer_callback   (const uint8 *buff, uint32 length) 
{ 
	uart_putbuff(DEBUG_UART, buff, length); 
	return 0; 
} 
//角度值清零 
void Ang_reset() 
{ 
	FJ_AngleSpeed = 0; 
	FJ_LastAngleSpeed = 0; 
	imu660ra_gyro_z = 0; 
	FJ_Angle = 0; 
 
} 
//计算（@1）
float _sqrt(float number)
{
	int32 i;
	float x2,y;
	const float threehalfs = 1.5F;
	
	x2 = number * 0.5F;
	y = number;
	i = *(int32 * ) &y;
	i = 0x5f3759df - (i >> 1);
	y = * (float * )&i;
	y = y * (threehalfs - (x2 * y * y));
	
	return y;	
}
//
